## 3.4.2 컨슈머API
프로듀서가 전송한 데이터는 카프카 브로커에 적재된다. 컨슈머는 적재된 데이터를 사용하기 위해 브로커로부터 데이터를 가져와서 필요한 처리를 한다.
### 카프카 컨슈머 프로젝트 생성
기본 설정으로 생성할 수 있는 오토 커밋 카프카 컨슈머 애플리케이션을 만들어 보자
- 카프카 메시지 생성
```shell
bin/kafka-console-producer.sh --bootstrap-server localhost:9092 --topic test
```
### 컨슈머 중요 개념
토픽의 파티션으로부터 데이터를 가져가기 위해 컨슈머를 운영하는 방법은 크게 2가지가 있다.
첫 번째는 1개 이상의 컨슈머로 이루어진 컨슈머 그룹을 운영하는 것이고 두 번째는 토픽의 특정 파티션만 구독하는 컨슈머를 운영하는 것이다.

컨슈머 그룹으로 묶인 컨슈머들은 토픽의 1개 이상 파티션들에 할당되어 데이터를 가져갈 수 있다. 반대로 1개의 파티션은 최대 1개의 컨슈머에 할당 가능하다.
파티션이 3개고 컨슈머가 4개이면 1개의 컨슈머는 할당되지 않는다.

컨슈머 그룹은 다른 컨슈머 그룹과 격리되는 특징을 가지고 있어 장애에 유연하게 대응할 수 있다. 
컨슈머 그룹의 컨슈머에 장애가 발생하면 장애가 발생한 컨슈머에 할당된 파티션은 장애가 발생하지 않은 컨슈머에게 재할당된다. 이러한 과정을 리밸런싱이라고 부른다.
가용성을 높이면서도 안정적인 운영을 도와주는 리밸런싱은 유용하지만 자주 일어나서는 안 된다.
리밸런싱이 발생할 때 파티션의 소유권을 컨슈머로 재할당하는 과정에서 해당 컨슈머 그룹의 컨슈머들이 토픽의 데이터를 읽을 수 없기 때문이다.
그룹 조정자는 리밸런싱을 발동시키는 역할을 하는데 컨슈머 그룹의 컨슈머가 추가되고 삭제될 때를 감지한다.
카프카 브로커 중 한 대가 그룹 조정자의 역할을 수행한다.

컨슈머는 카프카 브로커로부터 데이터를 어디까지 가져갔는지 커밋을 통해 기록한다. 특정 토픽의 파티션을 어떤 컨슈머 그룹이 몇 번째 가져갔는지 카프카 브로커 내부에서 사용되는 내부 토픽(_consumer_offsets)에 기록된다.
일정 간격마다 자동으로 커밋되는 비명시'오프셋 커밋'이 기본 설정이다. 비명시 오프셋 커밋은 편리하지만 poll() 메서드 호출 이후에 리밸런싱 또는 컨슈머 강제종료 발생 시 컨슈머가 처리하는 데이터가 중복 또는 유실될 수 있는 가능성이 있는 취약한 구조를 가지고 있다.
그러므로 데이터 중복이나 유실을 허용하지 않는 서비스라면 자동 커밋을 사용해서는 안된다.

명시적으로 오프셋을 커밋하려면 poll() 메서드 호출 이후에 반환받은 데이터의 처리가 완료되고 commitSync() 메서드를 호출하면 된다.
commitSync() 메서드는 커밋이 완료될 때까지 블로킹되어 있기 때문에 처리량이 떨어질 수 있다.
commitAsync() 메서드는 비동기로 동작하며 처리량을 높일 수 있지만 커밋이 실패할 현재 처리 중인 데이터의 순서를 보장하지 않으며 데이터의 중복 처리가 발생할 수 있다.

![image](https://github.com/user-attachments/assets/7e838620-704f-4f9c-bc35-64301b91bc08)

컨슈머의 내부 구조에 대해 알아보자. 컨슈머는 poll() 메서드를 통해 레코드들을 반환받지만 poll() 매소드를 호출하는 시점에 클러스터에서 데이터를 가져오는 것은 아니다.
컨슈머 애플리케이션을 실행하게 되면 내부에서 Fetcher 인스턴스가 생성되어 poll() 메서드를 호출하기 전에 미리 레코드들을 내부 큐로 가져온다. 
이후에 사용자가 명시적으로 poll() 메서드를 호출하면 컨슈머는 내부 큐에 있는 레코드들을 반환받아 처리를 수행한다.

### 컨슈머 주요 옵션
- 필수 옵션
  - bootstrap.servers
    - 프로듀서가 데이터를 전송할 대상 카프카 클러스터에 속한 브로커의 호스트 이름
  - key.deserializer
    - 레코드의 메시지 키를 역직렬화하는 클래스를 지정한다.
  - value.deserializer
    - 레코드의 메시지 값을 역직렬화하는 클래스를 지정한다.
- 선택 옵션
  - group.id
    - 컨슈머 그룹의 식별자로 사용되는 옵션이다. 기본값은 null이다.
  - auto.offset.reset
    - 컨슈머가 토픽의 파티션에서 데이터를 가져가기 위한 오프셋을 설정하는 옵션이다. 이미 컨슈머 오프셋이 있다면 이 옵션은 무시 된다. earliest, latest, none 중 하나를 설정할 수 있다.
      - earliest: 가장 이전의 오프셋부터 데이터를 가져간다.
      - latest: 가장 최근의 오프셋부터 데이터를 가져간다.
      - none: 컨슈머 그룹이 커밋한 오프셋이 없으면 에러를 발생시킨다.
  - enable.auto.commit
    - 컨슈머가 자동으로 오프셋을 커밋하는 옵션이다. 기본값은 true이다.
  - auto.commit.interval.ms
    - 자동으로 오프셋을 커밋하는 주기를 설정하는 옵션이다. 기본값은 5000ms(5초)이다.
  - max.poll.records
    - poll() 메서드 호출 시 반환받을 레코드의 최대 개수를 설정하는 옵션이다. 기본값은 500이다.
  - session.timeout.ms
    - 컨슈머가 브로커로부터 세션 타임아웃을 설정하는 옵션이다. 기본값은 10000ms(10초)이다.
  - heartbeat.interval.ms
    - 컨슈머가 브로커로부터 하트비트를 보내는 주기를 설정하는 옵션이다. 기본값은 3000ms(3초)이다.
  - max.poll.interval.ms
    - poll() 메서드 호출 사이의 최대 시간을 설정하는 옵션이다. 기본값은 300000ms(5분)이다.
  - isolation.level
    - 트랜잭션 메시지를 처리하는 옵션이다. read_uncommitted, read_committed 중 하나를 설정할 수 있다.
      - read_uncommitted: 트랜잭션 메시지를 처리하지 않는다.
      - read_committed: 트랜잭션 메시지를 처리한다.

### 동기 오프셋 커밋
poll 메서드가 호출된 이후에 commitSync() 메서드를 호출하여 오프셋 커밋을 명시적으로 수행할 수 있다. 동기 커밋의 경우 브로커로 커밋을 ㅇ요청한 이후에 커밋이 완료되기까지 기다린다.

### 비동기 오프셋 커밋
동기 오프셋 커밋을 사용할 경우 커밋 응답을 기다리는 동안 데이터 처리가 일시적으로 중단되기 때문에 더 많은 데이터를 처리하기 위해서 비동기 오프셋 커밋을 사용할 수 있다.
비동기 오프셋 커밋은 commitAsync()메서드를 호출하여 사용할 수 있다.

### 리밸런스 리스너를 가진 컨슈머
컨슈머 그룹에서 컨슈머가 추가 또는 제거되면 파티션을 컨슈머에 재할당하는 과정인 리밸런스가 일어난다.

### 파티션 할당 컨슈머
컨슈머를 운영할 때 subscribe 메서드를 사용하여 구독 형태로 사용하는 것 외에도 직접 파티션을 컨슈머에 명시적으로 할당하여 운영할 수도 있다.
컨슈머가 어떤 토픽, 파티션을 할당할지 명시적으로 선언할 때는 assign() 메서드를 사용하면 된다.

### 컨슈머에 할당된 파티션 확인 방법
컨슈머에 할당된 토픽과 파티션에 대한 정보는 assignment() 메서드로 확인할 수 있다.

### 컨슈머의 안전한 종료
정상적으로 종료되지 않은 컨슈머는 세션 타임아웃이 발생할때까지 컨슈머 그룹에 남는다.
KafkaConsumer 클래스의 wakeup() 메서드를 이용하여 KafkaConsumer 인스턴스를 안전하게 종료할 수 있다.



